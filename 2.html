<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gargantua Black Hole Simulation - Final Fix</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #000;
        overflow: hidden;
        font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
        color: white;
      }

      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      .ui-layer {
        position: absolute;
        z-index: 5;
        pointer-events: none;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        padding: 20px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .header {
        text-shadow: 0 0 10px rgba(255, 166, 0, 0.7);
      }

      h1 {
        margin: 0;
        font-weight: 300;
        letter-spacing: 8px;
        font-size: 1.5rem;
        text-transform: uppercase;
        color: #ffcc80;
        border-left: 3px solid #ff9900;
        padding-left: 15px;
      }

      .subtitle {
        font-size: 0.8rem;
        color: #aaa;
        margin-left: 20px;
        margin-top: 5px;
        letter-spacing: 2px;
      }

      .data-panel {
        align-self: flex-end;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
        padding: 20px;
        border-radius: 4px;
        max-width: 300px;
        border-right: 2px solid #ff9900;
      }

      .data-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        font-size: 0.9rem;
      }

      .label {
        color: #888;
      }

      .value {
        color: #fff;
        font-family: 'Courier New', monospace;
        font-weight: bold;
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ff9900;
        font-size: 1.2rem;
        z-index: 8;
        transition: opacity 0.5s;
      }

      .scanlines {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0) 50%,
          rgba(0, 0, 0, 0.1) 50%,
          rgba(0, 0, 0, 0.1)
        );
        background-size: 100% 4px;
        z-index: 4;
        pointer-events: none;
        opacity: 0.3;
      }

      .vignette {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        box-shadow: 0 0 150px rgba(0, 0, 0, 0.9) inset;
        pointer-events: none;
        z-index: 3;
      }

      #ui-container {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 320px;
        background: rgba(10, 15, 20, 0.9);
        border: 1px solid #445;
        border-left: 4px solid #dca868;
        padding: 20px;
        backdrop-filter: blur(5px);
        pointer-events: auto;
        font-family: 'Courier New', Courier, monospace;
        color: #fff;
        z-index: 15;
        transition: opacity 0.4s ease;
      }

      #ui-container h1 {
        font-size: 18px;
        margin: 0 0 15px 0;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: #dca868;
        border-bottom: 1px solid #445;
        padding-bottom: 10px;
      }

      .tab-bar {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
      }

      .tab-btn {
        flex: 1;
        border: 1px solid #445;
        background: rgba(10, 15, 20, 0.6);
        color: #aaa;
        padding: 6px 10px;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .tab-btn.active {
        border-color: #dca868;
        color: #000;
        background: #dca868;
      }

      .tab-panel {
        display: none;
      }

      .tab-panel.active {
        display: block;
      }

      .control-group {
        margin-bottom: 15px;
      }

      .control-group label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 12px;
        color: #aaa;
        margin-bottom: 5px;
      }

      .control-group label span {
        color: #dca868;
        font-size: 11px;
      }

      input[type='range'] {
        width: 100%;
        background: transparent;
        -webkit-appearance: none;
      }

      input[type='range']::-webkit-slider-runnable-track {
        width: 100%;
        height: 4px;
        background: #445;
        border-radius: 2px;
      }

      input[type='range']::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 14px;
        width: 14px;
        border-radius: 50%;
        background: #dca868;
        margin-top: -5px;
        cursor: pointer;
        box-shadow: 0 0 5px rgba(220, 168, 104, 0.8);
      }

      button {
        background: transparent;
        border: 1px solid #dca868;
        color: #dca868;
        padding: 8px 12px;
        font-family: inherit;
        font-size: 11px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.2s;
        width: 100%;
        margin-bottom: 6px;
      }

      button:hover {
        background: #dca868;
        color: #000;
        box-shadow: 0 0 10px rgba(220, 168, 104, 0.4);
      }

      button.active {
        background: #dca868;
        color: #000;
      }

      .telemetry {
        margin-top: 20px;
        border-top: 1px solid #334;
        padding-top: 10px;
        font-size: 10px;
        color: #6f8;
      }

      .telemetry div {
        margin-bottom: 3px;
        display: flex;
        justify-content: space-between;
      }

      .data-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        margin-top: 12px;
      }

      .data-card {
        border: 1px solid #334;
        border-radius: 10px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.35);
        font-size: 11px;
      }

      .data-card h3 {
        margin: 0 0 6px;
        font-size: 12px;
        letter-spacing: 2px;
        text-transform: uppercase;
        color: #dca868;
      }

      .data-card div {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
        color: #9fb7d0;
      }

      .data-card div span:last-child {
        color: #dca868;
      }

      #formula-panel {
        border: 1px solid #334;
        padding: 10px;
        margin-top: 12px;
        font-size: 10px;
        color: #9fb7d0;
        max-height: 180px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.4);
        white-space: pre-line;
      }

      .calc-console {
        margin-top: 16px;
        border: 1px solid #334;
        padding: 10px;
        border-radius: 12px;
        background: rgba(2, 4, 8, 0.85);
        font-family: 'JetBrains Mono', Consolas, monospace;
        position: relative;
        z-index: 14;
      }

      .calc-console.fullscreen {
        position: fixed;
        top: 20px;
        left: 20px;
        width: calc(100vw - 40px);
        height: calc(100vh - 40px);
        z-index: 200;
        background: rgba(3, 5, 10, 0.95);
        border-width: 2px;
        backdrop-filter: blur(6px);
        cursor: grab;
      }

      .calc-console.fullscreen #formula-input {
        min-height: calc(100vh - 260px);
      }

      .console-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 8px;
      }

      .console-header h3 {
        margin: 0;
        font-size: 12px;
        letter-spacing: 2px;
        text-transform: uppercase;
        color: #dca868;
      }

      .header-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .pill-button {
        border: 1px solid #445;
        background: rgba(0, 0, 0, 0.4);
        color: #dca868;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 10px;
        letter-spacing: 1px;
        cursor: pointer;
        width: auto;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .pill-button.active {
        border-color: #dca868;
        background: #dca868;
        color: #000;
      }

      .info-button {
        border: 1px solid #445;
        background: transparent;
        color: #dca868;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        font-size: 14px;
        cursor: pointer;
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .tooltip {
        position: fixed;
        top: 35px;
        right: 0;
        width: 260px;
        background: rgba(20, 24, 30, 0.95);
        color: #d1e9ff;
        padding: 10px;
        border: 1px solid #445;
        border-radius: 8px;
        font-size: 10px;
        line-height: 1.4;
        display: none;
        z-index: 205;
        cursor: grab;
      }

      .tooltip.visible {
        display: block;
      }

      #formula-input {
        width: 100%;
        min-height: 120px;
        border: 1px solid #445;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.5);
        color: #fefefe;
        font-size: 11px;
        font-family: 'JetBrains Mono', Consolas, monospace;
        padding: 8px;
        resize: vertical;
        box-sizing: border-box;
      }

      .console-actions {
        margin-top: 8px;
        display: flex;
        gap: 8px;
      }

      #formula-output {
        margin-top: 10px;
        font-size: 10px;
        color: #a5d9ff;
        min-height: 40px;
        white-space: pre-line;
      }

      #suggestion-list {
        margin-top: 8px;
        display: none;
        border: 1px solid #334;
        border-radius: 8px;
        background: rgba(5, 7, 12, 0.8);
        font-size: 10px;
        color: #d1e3ff;
        max-height: 120px;
        overflow-y: auto;
      }

      #suggestion-list.visible {
        display: block;
      }

      .suggestion-item {
        padding: 6px 8px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        cursor: pointer;
      }

      .suggestion-item:last-child {
        border-bottom: none;
      }

      .suggestion-item:hover {
        background: rgba(220, 168, 104, 0.1);
      }

      #start-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        transition: opacity 1s;
      }

      #loader {
        width: 60px;
        height: 60px;
        border: 2px solid #333;
        border-top: 2px solid #dca868;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .hidden {
        opacity: 0;
        pointer-events: none;
      }

      #subtitle-box {
        position: absolute;
        bottom: 40px;
        width: 100%;
        text-align: center;
        pointer-events: none;
        z-index: 12;
      }

      #subtitle-text {
        background: rgba(0, 0, 0, 0.6);
        color: #eee;
        padding: 10px 20px;
        border-radius: 4px;
        font-size: 14px;
        opacity: 0;
        transition: opacity 0.5s;
        display: inline-block;
        max-width: 600px;
      }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  </head>
  <body>
    <div id="start-overlay">
      <div id="loader"></div>
      <h2 style="color: #dca868; font-weight: lighter; letter-spacing: 4px; margin: 10px 0">GARGANTUA</h2>
      <p style="color: #666; font-size: 12px; margin-bottom: 30px">超大質量黑洞觀測系統</p>
      <button id="init-btn" style="width: 220px">啟動觀測</button>
    </div>

    <div id="loading" class="loading">系統初始化中...</div>

    <div class="ui-layer">
      <div class="header">
        <h1>Gargantua</h1>
        <div class="subtitle">超大質量黑洞實時觀測終端</div>
      </div>

      <div class="data-panel">
        <div class="data-row">
          <span class="label">質量 (Mass)</span>
          <span class="value">動態控制</span>
        </div>
        <div class="data-row">
          <span class="label">自旋 (Spin)</span>
          <span class="value">參數控制</span>
        </div>
        <div class="data-row">
          <span class="label">事件視界</span>
          <span class="value">即時計算</span>
        </div>
        <div class="data-row">
          <span class="label">距離</span>
          <span class="value">~10 Gly</span>
        </div>
        <div style="margin-top: 10px; font-size: 0.7rem; color: #666; border-top: 1px solid #333; padding-top: 5px">
          點擊並拖曳以旋轉視角<br />滾輪縮放
        </div>
      </div>
    </div>

    <div id="subtitle-box">
      <div id="subtitle-text"></div>
    </div>

    <div id="ui-container" class="hidden">
      <div class="tab-bar">
        <button class="tab-btn active" data-tab="controls">System Controls</button>
        <button class="tab-btn" data-tab="telemetry">Relativistic Data</button>
      </div>

      <div class="tab-panel active" id="controls-panel">
        <h1>System Controls</h1>
        <div class="control-group">
          <label>Black Hole Mass (Solar Masses) <span data-display="mass">1.0</span></label>
          <input type="range" id="mass-slider" min="0.1" max="3.0" step="0.1" value="1.0" />
        </div>

        <div class="control-group">
          <label>Spin Parameter a <span data-display="spin">0.95</span></label>
          <input type="range" id="spin-slider" min="0.0" max="0.998" step="0.001" value="0.95" />
        </div>

        <div class="control-group">
          <label>Accretion Disk Density <span data-display="density">1.0</span></label>
          <input type="range" id="density-slider" min="0.0" max="2.0" step="0.1" value="1.0" />
        </div>

        <div class="control-group">
          <label>Observer Inclination (°) <span data-display="inclination">60</span></label>
          <input type="range" id="inclination-slider" min="0" max="90" step="1" value="60" />
        </div>

        <div class="control-group">
          <label>Doppler Boost <span data-display="doppler">1.5</span></label>
          <input type="range" id="doppler-slider" min="0.5" max="3.0" step="0.05" value="1.5" />
        </div>

        <div class="control-group">
          <label>Disk Temperature / Exposure <span data-display="exposure">1.1</span></label>
          <input type="range" id="exposure-slider" min="0.6" max="1.6" step="0.02" value="1.1" />
        </div>

        <div class="control-group">
          <label>Camera Azimuth (°) <span data-display="azimuth">0</span></label>
          <input type="range" id="azimuth-slider" min="0" max="360" step="0.1" value="0" />
        </div>

        <div class="control-group">
          <label>Camera Elevation (°) <span data-display="elevation">20</span></label>
          <input type="range" id="elevation-slider" min="0" max="360" step="0.1" value="20" />
        </div>

        <div class="control-group">
          <label>Camera Zoom <span data-display="zoom">15.0</span></label>
          <input type="range" id="zoom-slider" min="5.0" max="40.0" step="0.5" value="15.0" />
        </div>

        <h1 style="margin-top: 20px">Data Logs / Audio</h1>
        <button id="narrate-intro">Analytic: Introduction</button>
        <button id="narrate-lensing">Analytic: Gravitational Lensing</button>
        <button id="narrate-horizon">Analytic: Event Horizon</button>
        <button id="toggle-ambience" class="active">Toggle Ambience</button>

        <div class="telemetry">
          <div><span>SPACETIME CURVATURE</span><span id="val-curve">NORMAL</span></div>
          <div><span>PHOTON SPHERE</span><span id="val-photon">STABLE</span></div>
          <div><span>RELATIVISTIC JETS</span><span>DETECTED</span></div>
        </div>
      </div>

      <div class="tab-panel" id="telemetry-panel">
        <h1>Relativistic Parameters</h1>
        <div class="data-grid">
          <article class="data-card">
            <h3>Gravitational</h3>
            <div>
              <span>R<sub>g</sub></span
              ><span id="metric-rg">--</span>
            </div>
            <div><span>ISCO</span><span id="metric-isco">--</span></div>
            <div><span>Photon Sphere</span><span id="metric-photon">--</span></div>
          </article>
          <article class="data-card">
            <h3>Relativity</h3>
            <div><span>Redshift z</span><span id="metric-redshift">--</span></div>
            <div><span>β (ISCO)</span><span id="metric-beta">--</span></div>
            <div><span>Time Dilation</span><span id="metric-time">--</span></div>
          </article>
          <article class="data-card">
            <h3>Kinematics</h3>
            <div><span>Doppler</span><span id="metric-doppler">--</span></div>
            <div><span>Orbital Period</span><span id="metric-period">--</span></div>
            <div><span>Flux (arb)</span><span id="metric-flux">--</span></div>
          </article>
          <article class="data-card">
            <h3>Observer</h3>
            <div><span>Inclination</span><span data-display="inclination">--</span></div>
            <div><span>Azimuth</span><span data-display="azimuth">--</span></div>
            <div><span>Zoom</span><span data-display="zoom">--</span></div>
          </article>
        </div>
        <div id="formula-panel">正在載入公式追蹤...</div>
      </div>

      <div id="calc-console" class="calc-console">
        <div class="console-header">
          <h3>Field Equations</h3>
          <div class="header-actions">
            <button class="pill-button active" id="console-toggle">LIVE</button>
            <button class="pill-button" id="console-fullscreen">⤢</button>
            <button class="info-button" id="console-info">i</button>
          </div>
        </div>
        <textarea id="formula-input">
doppler = sqrt((1+beta)/(1-beta))
inclination = 45
zoom = 18</textarea
        >
        <div id="suggestion-list"></div>
        <div class="console-actions">
          <button id="apply-formula">套用</button>
          <button id="clear-formula">重設範例</button>
        </div>
        <div id="formula-output">輸入參數或公式，像是 doppler = sqrt((1+beta)/(1-beta))</div>
        <div id="console-tooltip" class="tooltip">
          在此輸入觀測任務的參數方程式，每行使用 `=` 指派。<br />
          內建變數： r, a, beta, incl, Rg, ISCO, photon, z。<br />
          可按 Tab 套用建議，或切換 LIVE 以暫停即時計算。
        </div>
      </div>
    </div>

    <div class="scanlines"></div>
    <div class="vignette"></div>
    <div id="canvas-container"></div>

    <script>
      const snoise = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187,
                                    0.366025403784439,
                                   -0.577350269189626,
                                    0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v -   i + dot(i, C.xx);
                vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;

                i = mod289(i);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                                + i.x + vec3(0.0, i1.x, 1.0 ));

                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m ;
                m = m*m ;

                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;

                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }
        `;

      const particleVertexShader = `
            attribute float p_size;
            attribute float p_offset_angle;
            attribute float p_offset_radius;
            attribute float p_speed_mult;
            attribute vec3 p_color_base;
            attribute float p_spin_dir;

            uniform float time;
            uniform float rotation_speed;
            uniform float noise_strength;
            uniform float disk_inner_radius;
            uniform float disk_outer_radius;
            uniform float vertical_thickness;
            uniform float camera_y;

            varying vec3 vColor;
            varying float vAlpha;

            ${snoise}

            void main() {
                vec3 pos = position;

                float current_rotation_speed = rotation_speed * (pow(disk_outer_radius / p_offset_radius, 1.5)) * p_speed_mult * p_spin_dir;
                float current_angle = p_offset_angle + time * current_rotation_speed;

                float noise_scale_fine = 1.0 / (p_offset_radius * 0.5 + 1.0);
                float noiseX1 = snoise(vec2(current_angle * 15.0 + time * 1.2, p_offset_radius * 8.0 + time * 0.5)) * noise_strength * noise_scale_fine;
                float noiseY1 = snoise(vec2(current_angle * 12.0 + time * 1.5, p_offset_radius * 9.0 + time * 0.7)) * noise_strength * noise_scale_fine * 0.5;

                float noise_scale_coarse = 1.0 / (p_offset_radius * 0.2 + 1.0);
                float noiseX2 = snoise(vec2(current_angle * 5.0 + time * 0.3, p_offset_radius * 2.0 + time * 0.1)) * noise_strength * noise_scale_coarse * 0.5;
                float noiseY2 = snoise(vec2(current_angle * 4.0 + time * 0.4, p_offset_radius * 3.0 + time * 0.2)) * noise_strength * noise_scale_coarse * 0.3;

                float final_radius = p_offset_radius + noiseX1 + noiseX2;
                pos.x = final_radius * cos(current_angle);
                pos.y = final_radius * sin(current_angle);
                pos.z = (noiseY1 + noiseY2) * vertical_thickness * (1.0 - pow(abs(p_offset_radius - disk_inner_radius) / (disk_outer_radius - disk_inner_radius), 2.0));

                float r_norm = (p_offset_radius - disk_inner_radius) / (disk_outer_radius - disk_inner_radius);

                vec3 colorInner = vec3(1.0, 1.0, 1.0);
                vec3 colorYellow = vec3(1.0, 0.9, 0.4);
                vec3 colorOrange = vec3(1.0, 0.5, 0.1);
                vec3 colorRed = vec3(0.8, 0.1, 0.0);

                if (r_norm < 0.2) {
                     vColor = mix(colorInner, colorYellow, r_norm / 0.2);
                } else if (r_norm < 0.5) {
                     vColor = mix(colorYellow, colorOrange, (r_norm - 0.2) / 0.3);
                } else {
                     vColor = mix(colorOrange, colorRed, (r_norm - 0.5) / 0.5);
                }

                vColor *= p_color_base;

                float brightness_factor = 1.0;
                if (r_norm < 0.1) brightness_factor = 5.0;
                else if (r_norm < 0.4) brightness_factor = mix(5.0, 1.5, (r_norm - 0.1) / 0.3);
                else brightness_factor = mix(1.5, 0.5, (r_norm - 0.4) / 0.6);

                vColor *= brightness_factor;

                vAlpha = smoothstep(0.0, 0.05, r_norm) * (1.0 - smoothstep(0.9, 1.0, r_norm));
                vAlpha *= (1.0 - smoothstep(0.0, 0.5, abs(pos.z) / (vertical_thickness * disk_outer_radius * 0.5)));
                vAlpha *= p_size * 0.5;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = p_size * (600.0 / -mvPosition.z) * (1.0 - smoothstep(0.0, 0.5, r_norm));
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

      const particleFragmentShader = `
            uniform float doppler_shift;
            uniform float density_factor;

            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                vec2 coords = gl_PointCoord - 0.5;
                float dist = length(coords);
                if (dist > 0.5) {
                    discard;
                }

                float alpha_grad = smoothstep(0.5, 0.0, dist);
                float shift = clamp(doppler_shift - 1.0, -0.5, 1.5);
                vec3 warmBoost = vec3(1.1, 0.9, 0.6);
                vec3 coolBoost = vec3(0.5, 0.7, 1.0);
                vec3 finalColor = mix(vColor * (1.0 + shift * 0.35), mix(coolBoost, warmBoost, clamp(shift + 0.5, 0.0, 1.0)), clamp(shift, 0.0, 1.0));

                gl_FragColor = vec4(finalColor, vAlpha * alpha_grad * (1.0 - dist * 0.5) * density_factor);
            }
        `;

      const lensingShader = {
        uniforms: {
          tDiffuse: { value: null },
          lensingCenter: { value: new THREE.Vector2(0.5, 0.5) },
          lensingRadius: { value: 0.1 },
          lensingStrength: { value: 1.0 },
          aspectRatio: { value: 1.0 },
        },
        vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
        fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 lensingCenter;
                uniform float lensingRadius;
                uniform float lensingStrength;
                uniform float aspectRatio;
                varying vec2 vUv;

                vec2 lensDistort(vec2 uv, vec2 center, float radius, float strength) {
                    vec2 p = (uv - center) * vec2(aspectRatio, 1.0);
                    float r = length(p);
                    float angle = atan(p.y, p.x);

                    float rs = radius;

                    float distorted_r = r;
                    if (r < rs * 2.5) {
                        float normalized_r = r / (rs * 2.5);
                        distorted_r = rs * (normalized_r * (1.0 + strength) - strength * normalized_r * normalized_r);
                        distorted_r = max(0.0, distorted_r);
                    }

                    vec2 distorted_p = vec2(cos(angle), sin(angle)) * distorted_r;
                    return center + distorted_p / vec2(aspectRatio, 1.0);
                }

                void main() {
                    vec2 distorted_uv = lensDistort(vUv, lensingCenter, lensingRadius, lensingStrength);
                    if (distorted_uv.x < 0.0 || distorted_uv.x > 1.0 || distorted_uv.y < 0.0 || distorted_uv.y > 1.0) {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    } else {
                        gl_FragColor = texture2D(tDiffuse, distorted_uv);
                    }
                }
            `,
      };

      let scene, camera, renderer, composer, controls, lensingPass, bloomPass;
      let blackHoleSphere, accretionDiskParticles, warpedAccretionDiskGeometry, stars;

      const BH_RADIUS = 2.0;
      const DISK_INNER_RADIUS = BH_RADIUS * 1.05;
      const DISK_OUTER_RADIUS = BH_RADIUS * 7.0;
      const PARTICLE_COUNT = 250000;
      const STAR_COUNT = 200000;
      const VERTICAL_THICKNESS_FACTOR = 0.5;

      const params = {
        mass: 1.0,
        density: 1.0,
        zoom: 15.0,
        spin: 0.95,
        inclination: 60,
        doppler: 1.5,
        exposure: 1.1,
        azimuthBase: 0,
        elevationBase: 20,
      };

      const sliders = {};
      const displayRefs = {
        mass: document.querySelector('[data-display="mass"]'),
        spin: document.querySelector('[data-display="spin"]'),
        density: document.querySelector('[data-display="density"]'),
        inclination: document.querySelectorAll('[data-display="inclination"]'),
        doppler: document.querySelector('[data-display="doppler"]'),
        exposure: document.querySelector('[data-display="exposure"]'),
        azimuth: document.querySelectorAll('[data-display="azimuth"]'),
        elevation: document.querySelector('[data-display="elevation"]'),
        zoom: document.querySelectorAll('[data-display="zoom"]'),
      };

      const telemetryRefs = {
        rg: document.getElementById('metric-rg'),
        isco: document.getElementById('metric-isco'),
        photon: document.getElementById('metric-photon'),
        redshift: document.getElementById('metric-redshift'),
        beta: document.getElementById('metric-beta'),
      };

      const calcConsole = document.getElementById('calc-console');
      const formulaPanel = document.getElementById('formula-panel');
      const formulaInput = document.getElementById('formula-input');
      const suggestionList = document.getElementById('suggestion-list');
      const formulaOutput = document.getElementById('formula-output');
      const consoleFullscreen = document.getElementById('console-fullscreen');
      const consoleToggle = document.getElementById('console-toggle');
      const consoleInfo = document.getElementById('console-info');
      const consoleTooltip = document.getElementById('console-tooltip');
      const applyFormulaBtn = document.getElementById('apply-formula');
      const clearFormulaBtn = document.getElementById('clear-formula');
      let consoleLive = true;

      const formulaSuggestions = [
        { label: 'z = 1/sqrt(1 - 2/r + a^2/r^2) - 1', insert: 'z = 1/sqrt(1 - 2/r + a^2/r^2) - 1' },
        { label: 'doppler = sqrt((1+beta)/(1-beta))', insert: 'doppler = sqrt((1+beta)/(1-beta))' },
        { label: 'inclination = atan(beta) * 180 / PI', insert: 'inclination = atan(beta) * 180 / PI' },
        { label: 'zoom = Rg / 1e9', insert: 'zoom = Rg / 1e9' },
        { label: 'spin = min(0.998, spin + 0.01)', insert: 'spin = min(0.998, spin + 0.01)' },
      ];

      const narrationClips = {
        initial: new Audio('audio/Initial Narration.mp3'),
        intro: new Audio('audio/narrate-intro.mp3'),
        lensing: new Audio('audio/narrate-lensing.mp3'),
        horizon: new Audio('audio/narrate-horizon.mp3'),
      };

      Object.values(narrationClips).forEach(clip => {
        clip.preload = 'auto';
        clip.crossOrigin = 'anonymous';
        clip.volume = 0.85;
      });

      let audioCtx;
      let droneGain;
      let isAmbienceOn = true;
      let sceneInitialized = false;

      const SOLAR_MASS = 1.98847e30;
      const G = 6.6743e-11;
      const C = 299792458;

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      setupUI();
      setupTabs();
      setupConsole();
      document.getElementById('init-btn').addEventListener('click', startExperience);

      function startExperience() {
        if (sceneInitialized) return;
        sceneInitialized = true;
        document.getElementById('start-overlay').classList.add('hidden');
        document.getElementById('ui-container').classList.remove('hidden');
        initAudio();
        initScene();
        animate();
        playNarration('initial', '觀測站上線，目標：Gargantua。監控質量、自旋與吸積盤參數並啟用語音解說。');
      }

      function initScene() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0005);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 22);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = params.exposure;
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 150;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.2;
        controls.enablePan = false;

        createStars();
        createBlackHole();
        createAccretionDiskParticles();

        const renderScene = new THREE.RenderPass(scene, camera);

        bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.8, 0.05);

        lensingPass = new THREE.ShaderPass(lensingShader);
        lensingPass.uniforms.aspectRatio.value = window.innerWidth / window.innerHeight;

        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        composer.addPass(lensingPass);

        document.getElementById('loading').style.opacity = 0;
        setTimeout(() => (document.getElementById('loading').style.display = 'none'), 500);

        window.addEventListener('resize', onWindowResize, false);
        applySceneParameters();
      }

      function createStars() {
        const starGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(STAR_COUNT * 3);
        const colors = new Float32Array(STAR_COUNT * 3);

        for (let i = 0; i < STAR_COUNT; i++) {
          const i3 = i * 3;
          const r = Math.random() * 400 + 20;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);

          positions[i3] = r * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
          positions[i3 + 2] = r * Math.cos(phi);

          const color = new THREE.Color();
          color.setHSL(Math.random(), 0.8, Math.random() * 0.5 + 0.5);
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;
        }

        starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const starMaterial = new THREE.PointsMaterial({
          size: 0.1,
          sizeAttenuation: true,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
        });

        stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
      }

      function createBlackHole() {
        const sphereGeo = new THREE.SphereGeometry(BH_RADIUS * 0.95, 64, 64);
        const sphereMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        blackHoleSphere = new THREE.Mesh(sphereGeo, sphereMat);
        scene.add(blackHoleSphere);
      }

      function createDiskMaterial() {
        return new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            rotation_speed: { value: 0.3 },
            noise_strength: { value: 0.3 },
            disk_inner_radius: { value: DISK_INNER_RADIUS },
            disk_outer_radius: { value: DISK_OUTER_RADIUS },
            vertical_thickness: { value: VERTICAL_THICKNESS_FACTOR },
            camera_y: { value: 0 },
            doppler_shift: { value: params.doppler },
            density_factor: { value: params.density },
          },
          vertexShader: particleVertexShader,
          fragmentShader: particleFragmentShader,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        });
      }

      function createAccretionDiskParticles() {
        const geometry = new THREE.BufferGeometry();

        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const p_sizes = new Float32Array(PARTICLE_COUNT);
        const p_offset_angles = new Float32Array(PARTICLE_COUNT);
        const p_offset_radii = new Float32Array(PARTICLE_COUNT);
        const p_speed_mults = new Float32Array(PARTICLE_COUNT);
        const p_color_bases = new Float32Array(PARTICLE_COUNT * 3);
        const p_spin_dirs = new Float32Array(PARTICLE_COUNT);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const i3 = i * 3;
          positions[i3] = 0;
          positions[i3 + 1] = 0;
          positions[i3 + 2] = 0;

          p_offset_radii[i] = Math.random() * (DISK_OUTER_RADIUS - DISK_INNER_RADIUS) + DISK_INNER_RADIUS;
          p_offset_angles[i] = Math.random() * Math.PI * 2;
          p_sizes[i] = Math.random() * 0.3 + 0.1;
          p_speed_mults[i] = Math.random() * 0.4 + 0.8;

          const color = new THREE.Color();
          color.setHSL(0.05 + Math.random() * 0.05, 1.0, 0.6 + Math.random() * 0.4);
          p_color_bases[i3] = color.r;
          p_color_bases[i3 + 1] = color.g;
          p_color_bases[i3 + 2] = color.b;

          p_spin_dirs[i] = 1.0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('p_size', new THREE.BufferAttribute(p_sizes, 1));
        geometry.setAttribute('p_offset_angle', new THREE.BufferAttribute(p_offset_angles, 1));
        geometry.setAttribute('p_offset_radius', new THREE.BufferAttribute(p_offset_radii, 1));
        geometry.setAttribute('p_speed_mult', new THREE.BufferAttribute(p_speed_mults, 1));
        geometry.setAttribute('p_color_base', new THREE.BufferAttribute(p_color_bases, 3));
        geometry.setAttribute('p_spin_dir', new THREE.BufferAttribute(p_spin_dirs, 1));

        const material = createDiskMaterial();
        accretionDiskParticles = new THREE.Points(geometry, material);
        accretionDiskParticles.rotation.x = -Math.PI / 2;
        scene.add(accretionDiskParticles);

        const warpedMaterial = createDiskMaterial();
        warpedAccretionDiskGeometry = new THREE.Points(geometry, warpedMaterial);
        warpedAccretionDiskGeometry.rotation.x = 0;
        warpedAccretionDiskGeometry.scale.set(1.0, 1.0, 1.0);
        scene.add(warpedAccretionDiskGeometry);
      }

      function onWindowResize() {
        if (!camera || !renderer || !composer) return;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        if (lensingPass) {
          lensingPass.uniforms.aspectRatio.value = window.innerWidth / window.innerHeight;
        }
        applyCameraParams();
      }

      function animate() {
        requestAnimationFrame(animate);
        if (!composer) return;
        const time = performance.now() * 0.001;

        if (accretionDiskParticles) {
          accretionDiskParticles.material.uniforms.time.value = time;
          accretionDiskParticles.material.uniforms.camera_y.value = camera.position.y;
          accretionDiskParticles.rotation.z = time * 0.05;
        }

        if (warpedAccretionDiskGeometry) {
          warpedAccretionDiskGeometry.material.uniforms.time.value = time;
          warpedAccretionDiskGeometry.material.uniforms.camera_y.value = camera.position.y;
          warpedAccretionDiskGeometry.rotation.y = time * 0.05;
        }

        if (stars) {
          stars.rotation.y = time * 0.005;
        }

        controls.update();

        if (lensingPass && blackHoleSphere) {
          const vector = new THREE.Vector3(0, 0, 0);
          vector.project(camera);
          const cx = (vector.x + 1) / 2;
          const cy = (vector.y + 1) / 2;
          lensingPass.uniforms.lensingCenter.value.set(cx, cy);
          const distance = camera.position.distanceTo(blackHoleSphere.position);
          const fov = camera.fov * (Math.PI / 180);
          const screenRadius = Math.abs(BH_RADIUS / (distance * Math.tan(fov / 2)));
          lensingPass.uniforms.lensingRadius.value = screenRadius * 0.4;
        }

        composer.render();
      }

      function applyCameraParams() {
        if (!camera || !controls) return;
        const radius = clamp(params.zoom, 5, 90);
        const elevRad = THREE.MathUtils.degToRad(params.elevationBase);
        const azRad = THREE.MathUtils.degToRad(params.azimuthBase);
        const x = radius * Math.sin(azRad) * Math.cos(elevRad);
        const y = radius * Math.sin(elevRad);
        const z = radius * Math.cos(azRad) * Math.cos(elevRad);
        camera.position.set(x, y, z);
        controls.target.set(0, 0, 0);
        controls.update();
      }

      function applySceneParameters() {
        if (!renderer) return;
        renderer.toneMappingExposure = params.exposure;
        if (bloomPass) {
          const exposureNorm = clamp((params.exposure - 0.6) / 1.0, 0, 1);
          bloomPass.strength = 0.8 + exposureNorm * 1.2;
        }

        const massNorm = clamp((params.mass - 0.1) / (3.0 - 0.1), 0, 1);
        const bhScale = 0.85 + massNorm * 0.8;
        if (blackHoleSphere) blackHoleSphere.scale.setScalar(bhScale);
        const diskScale = 0.9 + massNorm * 0.9;
        if (accretionDiskParticles) accretionDiskParticles.scale.setScalar(diskScale);
        if (warpedAccretionDiskGeometry) warpedAccretionDiskGeometry.scale.setScalar(diskScale);

        const densityNorm = clamp(params.density / 2, 0, 1);
        const spinNorm = clamp(params.spin / 0.998, 0, 1);
        const densityFactor = 0.25 + densityNorm * 1.25;
        const rotationSpeed = 0.08 + spinNorm * 0.6;
        const noiseStrength = 0.1 + densityNorm * 0.5;
        const verticalThickness = VERTICAL_THICKNESS_FACTOR * (0.3 + densityNorm * 1.2);

        [accretionDiskParticles, warpedAccretionDiskGeometry].forEach(obj => {
          if (!obj) return;
          const uniforms = obj.material.uniforms;
          uniforms.rotation_speed.value = rotationSpeed;
          uniforms.noise_strength.value = noiseStrength;
          uniforms.vertical_thickness.value = verticalThickness;
          uniforms.doppler_shift.value = params.doppler;
          uniforms.density_factor.value = densityFactor;
        });

        const inclOffset = THREE.MathUtils.degToRad((params.inclination - 60) * 0.5);
        if (accretionDiskParticles) accretionDiskParticles.rotation.x = -Math.PI / 2 + inclOffset;
        if (warpedAccretionDiskGeometry) warpedAccretionDiskGeometry.rotation.x = inclOffset;

        if (lensingPass) {
          lensingPass.uniforms.lensingStrength.value = (0.8 + massNorm * 0.8) * (0.8 + spinNorm * 0.2);
        }

        if (controls) {
          controls.autoRotateSpeed = 0.05 + spinNorm * 0.35;
        }

        applyCameraParams();
        updateTelemetry();
      }

      function setupUI() {
        sliders.mass = document.getElementById('mass-slider');
        sliders.density = document.getElementById('density-slider');
        sliders.zoom = document.getElementById('zoom-slider');
        sliders.spin = document.getElementById('spin-slider');
        sliders.inclination = document.getElementById('inclination-slider');
        sliders.doppler = document.getElementById('doppler-slider');
        sliders.exposure = document.getElementById('exposure-slider');
        sliders.azimuth = document.getElementById('azimuth-slider');
        sliders.elevation = document.getElementById('elevation-slider');

        sliders.mass.addEventListener('input', e => {
          params.mass = parseFloat(e.target.value);
          updateDisplay('mass', params.mass);
          document.getElementById('val-curve').innerText = params.mass > 2.0 ? 'CRITICAL' : 'NORMAL';
          applySceneParameters();
        });

        sliders.density.addEventListener('input', e => {
          params.density = parseFloat(e.target.value);
          updateDisplay('density', params.density);
          applySceneParameters();
        });

        sliders.zoom.addEventListener('input', e => {
          params.zoom = parseFloat(e.target.value);
          updateDisplay('zoom', params.zoom, 1);
          applyCameraParams();
          updateTelemetry();
        });

        sliders.spin.addEventListener('input', e => {
          params.spin = parseFloat(e.target.value);
          updateDisplay('spin', params.spin, 3);
          document.getElementById('val-photon').innerText = params.spin > 0.92 ? 'SHEAR RISK' : 'STABLE';
          applySceneParameters();
        });

        sliders.inclination.addEventListener('input', e => {
          params.inclination = parseFloat(e.target.value);
          updateDisplay('inclination', params.inclination, 1);
          applySceneParameters();
        });

        sliders.doppler.addEventListener('input', e => {
          params.doppler = parseFloat(e.target.value);
          updateDisplay('doppler', params.doppler, 2);
          applySceneParameters();
        });

        sliders.exposure.addEventListener('input', e => {
          params.exposure = parseFloat(e.target.value);
          updateDisplay('exposure', params.exposure, 2);
          applySceneParameters();
        });

        sliders.azimuth.addEventListener('input', e => {
          params.azimuthBase = parseFloat(e.target.value);
          updateDisplay('azimuth', params.azimuthBase, 1);
          applyCameraParams();
        });

        sliders.elevation.addEventListener('input', e => {
          params.elevationBase = parseFloat(e.target.value);
          updateDisplay('elevation', params.elevationBase, 1);
          applyCameraParams();
        });

        document.getElementById('narrate-intro').onclick = () =>
          playNarration('intro', '黑洞是時空中連光都無法離開的區域，事件視界標記出無人返程的邊界。');

        document.getElementById('narrate-lensing').onclick = () =>
          playNarration('lensing', '注意光暈：重力透鏡效應將盤面後方的光線彎折，使其出現在影子上方與下方。');

        document.getElementById('narrate-horizon').onclick = () =>
          playNarration('horizon', '吸積盤以相對論速度旋轉，朝向觀測者一側更明亮、更偏藍，遠離的一側則偏紅黯淡。');

        document.getElementById('toggle-ambience').onclick = e => {
          isAmbienceOn = !isAmbienceOn;
          if (droneGain) {
            droneGain.gain.setTargetAtTime(isAmbienceOn ? 0.3 : 0, audioCtx.currentTime, 1.0);
          }
          e.target.classList.toggle('active');
        };

        updateDisplay('mass', params.mass);
        updateDisplay('spin', params.spin, 3);
        updateDisplay('density', params.density);
        updateDisplay('inclination', params.inclination, 1);
        updateDisplay('doppler', params.doppler, 2);
        updateDisplay('exposure', params.exposure, 2);
        updateDisplay('azimuth', params.azimuthBase, 1);
        updateDisplay('elevation', params.elevationBase, 1);
        updateDisplay('zoom', params.zoom, 1);
        document.getElementById('val-curve').innerText = 'NORMAL';
        document.getElementById('val-photon').innerText = 'STABLE';
        updateTelemetry();
      }

      function updateDisplay(key, value, digits = 2) {
        const ref = displayRefs[key];
        if (!ref) return;
        if (NodeList.prototype.isPrototypeOf(ref)) {
          ref.forEach(node => (node.innerText = Number(value).toFixed(digits)));
        } else {
          ref.innerText = Number(value).toFixed(digits);
        }
      }

      function setupTabs() {
        const buttons = document.querySelectorAll('.tab-btn');
        const panels = document.querySelectorAll('.tab-panel');
        buttons.forEach(btn => {
          btn.addEventListener('click', () => {
            buttons.forEach(b => b.classList.remove('active'));
            panels.forEach(panel => panel.classList.remove('active'));
            btn.classList.add('active');
            const target = btn.dataset.tab;
            document.getElementById(`${target}-panel`).classList.add('active');
          });
        });
      }

      function setupConsole() {
        if (!consoleToggle) return;
        consoleToggle.addEventListener('click', () => {
          consoleLive = !consoleLive;
          consoleToggle.classList.toggle('active', consoleLive);
          consoleToggle.textContent = consoleLive ? 'LIVE' : 'PAUSE';
        });

        if (consoleFullscreen) {
          consoleFullscreen.addEventListener('click', () => {
            const active = calcConsole.classList.toggle('fullscreen');
            consoleFullscreen.textContent = active ? '⤺' : '⤢';
            if (active) {
              calcConsole.style.left = '20px';
              calcConsole.style.top = '20px';
              calcConsole.style.right = 'auto';
              calcConsole.style.bottom = 'auto';
            } else {
              calcConsole.style.left = '';
              calcConsole.style.top = '';
              calcConsole.style.cursor = '';
            }
          });

          let consoleDragging = false;
          let consoleOffset = { x: 0, y: 0 };
          calcConsole.addEventListener('pointerdown', event => {
            if (!calcConsole.classList.contains('fullscreen')) return;
            const header = event.target.closest('.console-header');
            const actionArea = event.target.closest('.header-actions');
            if (!header || actionArea) return;
            consoleDragging = true;
            const rect = calcConsole.getBoundingClientRect();
            consoleOffset.x = event.clientX - rect.left;
            consoleOffset.y = event.clientY - rect.top;
            calcConsole.setPointerCapture(event.pointerId);
            calcConsole.style.cursor = 'grabbing';
          });
          calcConsole.addEventListener('pointermove', event => {
            if (!consoleDragging) return;
            calcConsole.style.left = `${event.clientX - consoleOffset.x}px`;
            calcConsole.style.top = `${event.clientY - consoleOffset.y}px`;
          });
          calcConsole.addEventListener('pointerup', event => {
            if (!consoleDragging) return;
            consoleDragging = false;
            calcConsole.releasePointerCapture(event.pointerId);
            calcConsole.style.cursor = 'grab';
          });
          calcConsole.addEventListener('pointerleave', event => {
            if (!consoleDragging) return;
            consoleDragging = false;
            calcConsole.releasePointerCapture(event.pointerId);
            calcConsole.style.cursor = 'grab';
          });
        }

        if (consoleInfo) {
          let tooltipDragging = false;
          let tooltipMoved = false;
          let dragOffset = { x: 0, y: 0 };
          consoleInfo.addEventListener('click', () => {
            consoleTooltip.classList.toggle('visible');
            if (consoleTooltip.classList.contains('visible')) {
              const rect = consoleInfo.getBoundingClientRect();
              consoleTooltip.style.left = `${rect.right + 10}px`;
              consoleTooltip.style.top = `${rect.top}px`;
            }
          });
          consoleTooltip.addEventListener('pointerdown', event => {
            tooltipDragging = true;
            tooltipMoved = false;
            const rect = consoleTooltip.getBoundingClientRect();
            dragOffset.x = event.clientX - rect.left;
            dragOffset.y = event.clientY - rect.top;
            consoleTooltip.style.cursor = 'grabbing';
            consoleTooltip.setPointerCapture(event.pointerId);
          });
          consoleTooltip.addEventListener('pointermove', event => {
            if (!tooltipDragging) return;
            tooltipMoved = true;
            consoleTooltip.style.left = `${event.clientX - dragOffset.x}px`;
            consoleTooltip.style.top = `${event.clientY - dragOffset.y}px`;
          });
          consoleTooltip.addEventListener('pointerup', event => {
            if (!tooltipDragging) return;
            tooltipDragging = false;
            consoleTooltip.releasePointerCapture(event.pointerId);
            consoleTooltip.style.cursor = 'grab';
          });
          consoleTooltip.addEventListener('click', () => {
            if (!tooltipMoved) {
              consoleTooltip.classList.remove('visible');
            }
          });
        }

        applyFormulaBtn.addEventListener('click', () => {
          evaluateFormulas(true);
        });
        clearFormulaBtn.addEventListener('click', () => {
          formulaInput.value = 'doppler = sqrt((1+beta)/(1-beta))\ninclination = 45\nzoom = 18';
          evaluateFormulas(false);
        });
        formulaInput.addEventListener('input', () => updateSuggestionList());
        formulaInput.addEventListener('keydown', event => {
          if (event.key === 'Tab' && suggestionList && suggestionList.classList.contains('visible')) {
            event.preventDefault();
            const first = suggestionList.querySelector('.suggestion-item');
            if (first) {
              insertSuggestion(first.dataset.insert);
            }
          }
        });
        formulaInput.addEventListener('blur', () => {
          setTimeout(() => suggestionList.classList.remove('visible'), 150);
        });
      }

      function evaluateFormulas(applyUpdates = false) {
        if (!formulaInput) return;
        const text = formulaInput.value.trim();
        if (!text) {
          formulaOutput.innerText = '輸入公式，如 doppler = sqrt((1+beta)/(1-beta))';
          return;
        }
        const massSolar = params.mass;
        const rg = gravitationalRadiusMeters(massSolar);
        const isco = iscoRadiusRg(params.spin);
        const photon = photonRadiusRg(params.spin);
        const redshift = gravitationalRedshiftRg(photon + 0.05, params.spin);
        const beta = orbitalBeta(isco, params.spin);
        const incl = THREE.MathUtils.degToRad(params.inclination);
        const context = { r: photon, a: params.spin, beta, incl, Rg: rg, ISCO: isco, photon, z: redshift };
        const assignments = {};
        const outputs = [];
        const lines = text.split(/\n+/);
        for (const lineRaw of lines) {
          const line = lineRaw.trim();
          if (!line) continue;
          const parts = line.split('=');
          if (parts.length !== 2) {
            outputs.push(`無法解析：${line}`);
            continue;
          }
          const label = parts[0].trim();
          const expr = parts[1].trim();
          try {
            const fn = new Function('r', 'a', 'beta', 'incl', 'Rg', 'ISCO', 'photon', 'z', `return ${expr};`);
            const value = fn(
              context.r,
              context.a,
              context.beta,
              context.incl,
              context.Rg,
              context.ISCO,
              context.photon,
              context.z,
            );
            outputs.push(`${label} = ${Number(value).toFixed(6)}`);
            assignments[label.toLowerCase()] = Number(value);
          } catch (error) {
            outputs.push(`${label}: 錯誤 (${error.message})`);
          }
        }
        formulaOutput.innerText = outputs.join('\n');
        if (applyUpdates) {
          applyFormulaAssignments(assignments);
        }
      }

      function updateSuggestionList() {
        if (!suggestionList) return;
        const caret = formulaInput.selectionStart;
        const text = formulaInput.value.slice(0, caret);
        const token = text.split(/[\s=()+\\-*/]+/).pop();
        if (!token || token.length < 2) {
          suggestionList.classList.remove('visible');
          return;
        }
        const matcher = token.toLowerCase();
        const matches = formulaSuggestions.filter(item => item.label.toLowerCase().includes(matcher)).slice(0, 5);
        if (matches.length === 0) {
          suggestionList.classList.remove('visible');
          return;
        }
        suggestionList.innerHTML = '';
        matches.forEach(item => {
          const div = document.createElement('div');
          div.className = 'suggestion-item';
          div.textContent = item.label;
          div.dataset.insert = item.insert;
          div.addEventListener('click', () => insertSuggestion(item.insert));
          suggestionList.appendChild(div);
        });
        suggestionList.classList.add('visible');
      }

      function insertSuggestion(text) {
        const caret = formulaInput.selectionStart;
        const before = formulaInput.value.slice(0, caret);
        const after = formulaInput.value.slice(formulaInput.selectionEnd);
        const token = before.split(/[\s=()+\\-*/]+/).pop() || '';
        const newBefore = before.slice(0, before.length - token.length) + text;
        formulaInput.value = newBefore + after;
        const newCaret = newBefore.length;
        formulaInput.setSelectionRange(newCaret, newCaret);
        updateSuggestionList();
        suggestionList.classList.remove('visible');
      }

      function applyFormulaAssignments(assignments) {
        const setIfDefined = (key, setter) => {
          if (assignments[key] !== undefined && !Number.isNaN(assignments[key])) {
            setter(assignments[key]);
          }
        };
        setIfDefined('mass', val => {
          params.mass = clamp(val, 0.1, 3.0);
          sliders.mass.value = params.mass;
          updateDisplay('mass', params.mass);
        });
        setIfDefined('spin', val => {
          params.spin = clamp(val, 0.0, 0.998);
          sliders.spin.value = params.spin;
          updateDisplay('spin', params.spin, 3);
        });
        setIfDefined('inclination', val => {
          params.inclination = clamp(val, 0, 90);
          sliders.inclination.value = params.inclination;
          updateDisplay('inclination', params.inclination, 1);
        });
        setIfDefined('doppler', val => {
          params.doppler = clamp(val, 0.5, 3.0);
          sliders.doppler.value = params.doppler;
          updateDisplay('doppler', params.doppler, 2);
        });
        setIfDefined('exposure', val => {
          params.exposure = clamp(val, 0.6, 1.6);
          sliders.exposure.value = params.exposure;
          updateDisplay('exposure', params.exposure, 2);
        });
        setIfDefined('zoom', val => {
          params.zoom = clamp(val, 5.0, 40.0);
          sliders.zoom.value = params.zoom;
          updateDisplay('zoom', params.zoom, 1);
        });
        setIfDefined('density', val => {
          params.density = clamp(val, 0.0, 2.0);
          sliders.density.value = params.density;
          updateDisplay('density', params.density, 2);
        });
        setIfDefined('azimuth', val => {
          params.azimuthBase = ((val % 360) + 360) % 360;
          sliders.azimuth.value = params.azimuthBase;
          updateDisplay('azimuth', params.azimuthBase, 1);
        });
        setIfDefined('elevation', val => {
          params.elevationBase = ((val % 360) + 360) % 360;
          sliders.elevation.value = params.elevationBase;
          updateDisplay('elevation', params.elevationBase, 1);
        });
        updateTelemetry();
        applySceneParameters();
      }

      function gravitationalRadiusMeters(massSolar) {
        return (2 * G * massSolar * SOLAR_MASS) / (C * C);
      }

      function iscoRadiusRg(spin) {
        const a = Math.min(Math.max(spin, -0.998), 0.998);
        const term = Math.cbrt(1 - a * a);
        const z1 = 1 + term * (Math.cbrt(1 + a) + Math.cbrt(1 - a));
        const z2 = Math.sqrt(3 * a * a + z1 * z1);
        const sign = a >= 0 ? 1 : -1;
        return 3 + z2 - sign * Math.sqrt((3 - z1) * (3 + z1 + 2 * z2));
      }

      function photonRadiusRg(spin) {
        const a = Math.abs(Math.min(Math.max(spin, -0.999), 0.999));
        const angle = (2 / 3) * Math.acos(-a);
        return 2 * (1 + Math.cos(angle));
      }

      function gravitationalRedshiftRg(rRg, spin) {
        const r = Math.max(rRg, 1.0001);
        const a = Math.min(Math.max(spin, -0.998), 0.998);
        const gm = 1 - 2 / r + (a * a) / (r * r);
        return 1 / Math.sqrt(Math.max(gm, 1e-6)) - 1;
      }

      function orbitalBeta(rRg, spin) {
        const r = Math.max(rRg, 1.0001);
        const omega = 1 / (Math.pow(r, 1.5) + spin);
        return Math.min(Math.abs((r * omega) / C), 0.99);
      }

      function updateTelemetry() {
        const massSolar = params.mass;
        const massKg = massSolar * SOLAR_MASS;
        const rg = gravitationalRadiusMeters(massSolar);
        const isco = iscoRadiusRg(params.spin);
        const photon = photonRadiusRg(params.spin);
        const redshift = gravitationalRedshiftRg(photon + 0.05, params.spin);
        const beta = orbitalBeta(isco, params.spin);

        if (telemetryRefs.rg) telemetryRefs.rg.innerText = `${rg.toExponential(3)} m`;
        if (telemetryRefs.isco) telemetryRefs.isco.innerText = `${isco.toFixed(3)} Rg`;
        if (telemetryRefs.photon) telemetryRefs.photon.innerText = `${photon.toFixed(3)} Rg`;
        if (telemetryRefs.redshift) telemetryRefs.redshift.innerText = redshift.toFixed(4);
        if (telemetryRefs.beta) telemetryRefs.beta.innerText = beta.toFixed(4);
        const timeDilation = 1 + redshift;
        const dopplerFactor = Math.sqrt((1 + beta) / (1 - beta));
        const periodSeconds = 2 * Math.PI * (Math.pow(isco, 1.5) + params.spin) * (rg / C);
        const flux = params.density * Math.pow(params.exposure, 4) * 1e-3;
        const timeRef = document.getElementById('metric-time');
        if (timeRef) timeRef.innerText = `${timeDilation.toFixed(3)}×`;
        const dopplerRef = document.getElementById('metric-doppler');
        if (dopplerRef) dopplerRef.innerText = dopplerFactor.toFixed(3);
        const periodRef = document.getElementById('metric-period');
        if (periodRef) periodRef.innerText = `${(periodSeconds / 60).toFixed(2)} min`;
        const fluxRef = document.getElementById('metric-flux');
        if (fluxRef) fluxRef.innerText = `${flux.toExponential(2)} arb`;

        if (formulaPanel) {
          formulaPanel.innerText = `
R_g = 2GM/c²
    = 2 × ${G} × ${massKg.toExponential(3)} / ${C}²
    = ${rg.toExponential(4)} m

r_ISCO(a=${params.spin.toFixed(3)}) = ${isco.toFixed(4)} R_g
r_ph = 2[1 + cos(2/3·acos(-|a|))] = ${photon.toFixed(4)} R_g

z = 1/√(1 - 2/r + a²/r²) - 1
    r = r_ph + 0.05 → z = ${redshift.toFixed(4)}

β = r·ω/c,  ω = 1/(r^{3/2} + a) → β = ${beta.toFixed(4)}
                `;
        }

        if (consoleLive) {
          evaluateFormulas(false);
        }
      }

      function initAudio() {
        if (audioCtx) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();

        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc1.type = 'sine';
        osc1.frequency.value = 50;

        osc2.type = 'sawtooth';
        osc2.frequency.value = 0.2;
        const modGain = audioCtx.createGain();
        modGain.gain.value = 20;

        osc2.connect(modGain);
        modGain.connect(osc1.frequency);

        filter.type = 'lowpass';
        filter.frequency.value = 200;

        osc1.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        osc1.start();
        osc2.start();

        droneGain = gain;
        droneGain.gain.value = 0.3;
      }

      function showSubtitle(text) {
        const subBox = document.getElementById('subtitle-text');
        subBox.innerText = text;
        subBox.style.opacity = 1;
        setTimeout(() => {
          subBox.style.opacity = 0;
        }, 6000);
      }

      function playNarration(id, text) {
        showSubtitle(text);
        const clip = narrationClips[id];
        if (!clip) return;
        Object.values(narrationClips).forEach(audio => {
          audio.pause();
          audio.currentTime = 0;
        });
        clip.play().catch(() => {});
      }
    </script>
  </body>
</html>
